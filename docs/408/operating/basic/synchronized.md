---
title: 同步
date: 2022-10-24
tags:
  - OperatingSystem
---

> 同步和互斥，极重要的概念，参考 [JUC 编程](https://northboat-docs.netlify.app/dev/java/juc/lock.html)

## 同步和互斥的概念

并发是操作系统的基本特征，引入进程/线程使多道程序可以并发，同时带来很复杂的运行环境，各进程之间既同步（合作实现作业），又互斥（资源占用），为了保证多个进程有条不紊工作，引入**同步机制**

各种进程之间相互制约，使并发执行的诸进程能够有效的共享资源和相互合作

- 直接制约：由进程合作引起
- 间接制约：由资源共享引起

互斥和同步是**协调进程执行顺序**的常见方式，均属于低级通信，设计数据量极少

特点：效率低；对用户不透明

### 基本概念

临界资源：一次仅允许一个进程访问的资源，如**打印机、公共变量（全局变量）**，需要互斥访问

临界区：一段代码，访问临界资源的代码段。进入临界区需要加锁，出临界区解锁

互斥：A 访问，其余不能访问

同步：必须等 A、C 执行完毕后，B 才能开始执行

同步机制：实现进程同步/互斥的方法

**同步机制应该遵循的准则**

- 空闲让进：临界区无进程，允许一个请求者执行临界区代码
- 忙则等待：临界区有进程，其余欲进入者需等待
- 有限等待：等待进入临界区的进程，其等待时间必须有限，避免饥饿
- 让权等待：进程无法进入临界区，应立即释放处理机资源

### 硬件实现同步互斥

1、中断：实现互斥最简单的硬件方法

- 关中断：防止之后流程被打断
- 锁测试：锁空闲则上锁，否则继续测试（死循环）
- 进入临界区：执行代码
- 开锁
- 开中断

缺点

- 滥关中断可能导致严重后果
- 长时间关中断限制处理器交叉执行程序的能力
- 多核 CPU 下，在一个处理器上关中断，并不能防止其他处理器访问临界资源

2、TS 指令：借助硬件测试实现互斥

```c
int TS(int *lock){
    int old = *lock;
    *lock = true; // 令临界资源 lock 为 true，上锁
    return old; // 返回上一个 lock 状态
}
```

为每个临界资源设置布尔变量 lock，初值为 false，表示空闲

```c
do{
    while(TS(&lock)) {} // 测试，当 lock 为 true，死循环等待
    critical section; // 临界区
    lock = false; // 解锁
}while(true);
```

等待期间不断测试，始终占用 CPU，不满足让权等待的同步准则

3、swap 指令：对换指令，交换两个 lock 和 key 布尔值的内容，lock 是表示临界资源是否被占用的全局变量，key 为 true

```c
void swap(int *lock, int *key){
    int t = *key;
    *lock = *key;
    *key = t;
}
```

只有当 key 的值被交换成 false，才能进入临界区

```c
do{
    key = true;
    do{
        swap(&lock, &key);
    }while(key != false); // 只有当 lock 的值为 false，交换到 key 时，key 为 false，退出 while 循环
    critical section; // 临界区
    lock = false; // 解锁
}while(true);
```

TS 和 SWAP 的缺点：若临界资源繁忙，其余欲访问的临界区进程只能不断测试，处于**忙等状态**，白白占用 CPU 资源，且无法处理复杂的同步问题

### 软件实现同步互斥

> 一定要会推导并发进程的执行过程，发现同步问题

1、单标志：适用一个全局变量 flag 标记一个临界资源，只有 flag 满足当前进程的规定，才能进入临界区，否则等待

```c
int flag = 1;

//进程 p1
void p1(){
    do{
        while(flag != 1){
            critical section;
            flag = 2;
        }
    }while(1);
}

//进程p2
void p2(){
    do{
        while(flag != 2) {}
        critical section;
        flag = 1;
    }while(1);
}
```

只有当进程 p1 执行完毕后，将 flag 赋值为 2，进程 p2 才能进入临界区；同理，只有当 p2 结束后，将 flag 赋值为 1，p1 才能进入临界区

- 不符合**空闲让进**（资源空闲，应接受任何一个请求）的规则：若 p1 不执行，即使资源空闲，p2 也不能进入临界区

2、多标志、先测试：适用一组全局标记对临界资源上锁，每个标记对应一个进程，只有当所有标记均为 false 时，当前进程才能进入临界区

```c
bool flags[] = {false, false};

//进程 p0
void p0(){
    while(flags[1]){} // 测试进程p1是否占用临界资源
    flags[0] = true; // 上锁
    critical section;
    flags[0] = false; // 解锁
}

//进程 p1
void p1(){
    while(flags[0]){} // 测试进程p0是否占用临界资源
    flags[1] = true; // 上锁
    critical section;
    flags[1] = false; // 解锁
}
```

如果 p0、p1 并发执行，若执行`while(flags[0])`后，下一条指令为`while(flags[1])`，在 p0 中尚未上锁，p1 将测试成功，进程 p0、p1 就会同时进入临界区，违反**忙则等待**（只能同时一个进程进入同一个资源临界区，其余等待）准则

3、多标志、后测试

```c
bool flags[] = {false, false};

//进程 p0
void p0(){
    flags[0] = true; // 先上锁
    while(flags[1]){} // 测试进程p1是否占用临界资源
    critical section;
    flags[0] = false; // 解锁
}

//进程 p1
void p1(){
    flags[1] = true; // 先上锁
    while(flags[0]){} // 测试进程p0是否占用临界资源
    critical section;
    flags[1] = false; // 解锁
}
```

若 p0、p1 并发执行，连续上锁，则会出现死锁，且实际上临界资源并未被占用，违反了**空闲让进和有限等待**（等待时间必须有限）准则

4、Peterson 算法：在多标志、后测试的基础上再加入一个单标志 turn，当 pi 进程欲进入临界区时，令`flags[i] = true; turn = j`，其中 i 不等于 j，等待条件为`while(flags[j] && turn==j)`

```c
bool flags[] = {false, false};
int turn = 0;

//进程 p0
void p0(){
    flags[0] = true, turn = 1;; // 当前进程上锁
    while(flags[1] && turn == 1){} // 测试进程p1是否占用临界资源
    critical section;
    flags[0] = false; // 解锁
}

//进程 p1
void p1(){
    flags[1] = true, turn = 0;; // 当前进程上锁
    // 测试进程p0是否占用临界资源
    // 测试并发执行时，turn = 0 和等待语句
    while(flags[0] && turn == 0){}
    critical section;
    flags[1] = false; // 解锁
}
```

先上锁的进程一定会先进入临界区，假设第 i 进程最先上锁

- 首先因为先上锁，`flags[i] = true`，其余任意进程的条件一（flags[i]）都会卡住
- 上锁后，只有两种可能，一种是执行 i 进程的测试等待语句，另一种是执行其他进程的上锁语句
  - 若直接执行等待语句，这时其他进程还尚未标记 flags，while 条件不成立，跳过 while，进入临界区
    - 其他进程再上锁，进行测试循环，条件一（flags）和条件二（turn）都会符合，死循环直到 flags[i] 为 false
  - 若执行其他进程的上锁语句，会标记上 flags，但 turn 会被重新赋值为另一值，进程 i 测试语句的条件二将不符合，同样会跳过 while 语句，进入临界区
    - 而其余进程由于条件一（flags）和条件二（自己设的 turn）均满足，将会卡死在测试语句，直到 flags[i] 为 false

完美满足同步的四个准则

## 锁

> 了解

锁是一种同步机制，限制任意时刻只有一个进程进入临界区

### 锁操作

解锁：锁变量设置为开启状态

加锁

- 流程：读取内存锁变量的值，已加锁返回失败信息，未加锁上锁后返回成功信息
- 问题：操作控制不当，可能导致多个进程均加锁成功
  - 单核状态下，并发进程，进程一读取内存锁变量后，发生中断，进程二也读取内存锁变量，均读到开锁，同时进入临界区
  - 多核状态下，并行执行，同时读取同一个锁变量，同时修改锁变量为上锁状态，均返回成功
- 常见解决方法
  - 单核环境：关中断；TS 指令读取内存锁变量值；读、判断、修改锁三个操作作为一个原子操作
  - 多核状态：swap 交换指令

### 锁类型

互斥锁：最基本的同步方式，用于保护临界区，保证任何时刻仅有一个进程执行临界区代码，各进程串行进入临界区，效率低

乐观锁：读直接进行，写前判断锁状态

悲观锁：操作数据就上锁

## 信号量

信号量（semaphore）是常用且有效的同步机制，由“信号量”和“PV操作”两部分组成，用于解决 n 个进程的临界区互斥使用、进程同步、实现前驱关系等

### 类型

1、整型信号量：表示可用资源数量，除初始化之外，仅能通过以下两个原子操作读写

P 操作：wait(S)，对信号量进行减一操作

```c
void wait(semaphore S){
    while(s <= 0){}
    S = S-1;
}
```

V 操作：signal(S)，对信号量进行加一操作

```c
void(semaphore S){
    S = S+1;
}
```

缺点：wait 操作可能导致忙等；不遵循“让权等待”准则

- 让权等待：当进程无法进入临界区时，主动释放资源，放弃进入

2、记录型信号量：结构体，又一个整型变量 value 和一个进程链表 L 构成

- value 大于 0，表示资源有 value 个；小于 0，说明阻塞队列中有 -value 个进程

定义

```c
typedef struct{
    int value;
    linkProcess L;
}semaphore;

semaphore S;
```

P 操作：sait(S)，减一

```c
void wait(semaphore S){
    S.value = S.value-1;
    // 小于 0 说明无空闲资源（原先最大 value 为 0，即无资源），将进程加入就绪队列，阻塞
    if(S.value < 0){
        block(S.L);
    }
}
```

V 操作：signal(S)，加一

```c
void signal(semaphore S){
    S.value = S.value+1;
    // 如果 value <= 0，说明原先 value 至多为 -1，队列中至少有一个等待进程，对其进行唤醒
    if(S.value <= 0){
        wakeup(S, L)
    }
}
```

特点：遵循让权等待策略；存在多个进程等待访问同一临界资源情况

3、AND 型信号量：可以处理多个并发进程共享多个临界资源的情况

4、信号量集：原子操作中对 S 的加减，一次可以进行多个数量，既表示一次加减资源的数量，也表示多种资源

### 应用

实现进程互斥：为临界资源设置互斥信号量

```c
semaphore mutex = 1;
void P(semaphore S){
    while(1){
        // 互斥，则自我阻塞，等待
        wait(mutex);
        critical section; //临界区
        signal(mutex);
    }
}
```

实现进程同步：设 P1，P2并发执行，P1 消费 A，产生 B，P2 消费 B，产生 A

```c
int A = 0, B = n;
void P1(){
    wait(A);
    make_b();
    signal(B);
}

void P2(){
    wait(B);
    make_a();
    signal(A);
}
```

实现前驱关系：设 P1、P2 种有语句 S2、S2，希望在执行 S1 后再执行 S2

```c
semaphore S = 0;
void P1(){
    S1();
    signal(S);
}

void P2(){
    wait(S);
    S2();
}

void main(){
    P1();
    P2();
}
```

## 管程和条件变量

信号量机制是一种方便有效的同步机制，但存在不便之处

- 同步操作分散：同步操作分散于各个进程，各个进程使用自己独立的信号量
- 易读性差：是否正确需要分析整个系统或并发程序

为使同步机制更有效，采用面向对象思想，用共享数据结构表示共享资源

### 管程

管程，将信号量及其操作原语封装在一个对象内部，一个管程定义了一个数据结构和并发进程在该数据结构上执行的一组操作（包括同步机制）

- 其实就相当于一个 JAVA 类，内部需要共享的资源使用 synchronized 修饰的函数对外提供接口，或使用 ReentrantLock 锁对各函数/资源进行相互制约，实现同步
