---
title: 死锁
date: 2022-10-24
tags:
  - OperatingSystem
---

## 死锁概念

> 过于忙碌 ——> 死锁，物极必反

资源竞争引发的恶果，多个进程在运行过程中可能因争夺资源出现的一种无外力作用时无法向前推进的僵局，称作死锁

- 比如哲学家同时拿左手筷子，出现僵局（死锁）

### 资源分类

是否可重用

- 可重用资源：可供用户重复使用的资源，其中每个单元每次只能分配给一个进程，不允许多进程共享；一般来说数量固定，程序无法创建
- 可消耗资源：进程运行期间，可由进程动态创建的资源，如指针
  - 消耗性资源的单元数可在执行期间动态变化
  - 进程运行过程可以不断创建该类资源
  - 生产者进程创建，消耗者进程消耗

是否可抢占

- 可抢占资源：进程获得资源后（尚未用完），可被强制回收并分配给其他进程，如 CPU 和内存
- 不可抢占资源：进程获取资源后必须得用完自行释放，如磁带打印机

死锁产生的根本原因：资源不足

**死锁产生的具体原因**

- 竞争消耗性资源
- 进程间推进顺序非法
- 竞争不可剥夺资源
- 请求和释放资源的顺序不当

### 死锁产生的必要条件

> 重点捏，解决死锁 ——> 打破必要条件

互斥使用：进程对所分配资源具有排他性

请求保持：进程已经保持了至少一个资源，又提出新的资源请求，但进程请求的资源已被占用，进程请求资源阻塞，此时进程保持请求，同时该进程已占用的资源将保持不释放

不可抢占：进程已获得的资源必须得自己执行完毕后自行释放

循环等待：发生死锁时，必然存在进程-资源循环链

## 死锁预防

> 死锁的一种解决办法

采取限制措施破坏死锁的一个或多个必要条件

- 互斥使用：不可破坏
- 破坏“请求保持”条件
  - 协议一：进程执行过程中不申请资源，初始分配时就分配所有所需资源
  - 协议二：进程获取初期所需资源后，开始执行
- 破坏“不可抢占”条件：提出新请求无法得到满足时，释放所有已获得的资源
- 破坏“循环等待”条件：对所有系统资源进行线性排序，进程必须按序号递增顺序申请资源
  - 问题一：增加新设备排序很麻烦
  - 问题二：申请资源的顺序可能很不合理，造成浪费

## 死锁避免

> 银行家算法

资源动态分配过程中，防止进入“不安全”状态（有可能死锁的状态）

系统安全状态：进程序列顺序调度资源时，系统资源能够最大化满足各进程顺序执行完毕，那么我们称这个进程序列是系统安全的

- 安全状态一定不死锁
- 不安全状态不一定死锁
- 避免死锁的实质是系统进行资源分配时，使系统不进入不安全状态

### 银行家算法

银行家算法：设系统 m 类资源，n 个进程

4 个数据结构

- 可利用资源数组`Available[i]`：反映第 i 类可利用资源的数量
- 最大需求矩阵`Max[i][j]`：表示第 i 个进程对第 j 类资源的最大需求量
- 分配矩阵`Allocation[i][j]`：表示第 i 个进程已经具有第 j 类资源的个数
- 需求矩阵`Need[][]`：表示第 i 个进程还需要第 j 类资源的个数

其中`Max[i][j] = Need[i][j] + Allocation[i][j]`

设`Request[i]`是第 i 个进程 P 的请求向量，若`Request[i][j] = k`，则说明进程 i 需要第 j 类资源 k 个，当 P 发出请求后，系统将以以下顺序进行检查

- `Request[i][j] <= Need[i][j]`，转下一步，否则出错（请求的不大于需要的）
- `Request[i][j] <= Available[j]`，转下一步，否则等待（请求的不大于空闲的）
- **尝试**将资源分配给进程 P，同时修改数据结构数值
  - `Available[j] = Available[j] - Request[i][j]`
  - `Allocation[i][j] = Allocation[i][j] + Request[i][j]`
  - `Need[i][j] = Need[i][j] - Request[i][j]`
- 安全性检测：若分配后系统处于安全状态，则将资源实际分配给 P；否则取消本次尝试，恢复原来的资源分配状态（恢复数据结构），P 进入等待

### 安全性检测

如何进行安全性检测？判断必须要熟且快，因为分少但流程长

- 设置两个向量
  - 工作向量`Work[j]`：表示**当前进程**所需第 j 类资源的数量，初始状态时`Work[j] == Available[j]` 
  - 结束向量`Finish[i]`：表示系统能够提供足够资源以供第 i 个进程顺利运行完毕，初值为 false
- 从进程集合中找到一个`Finish[]`为 false 的变量，假设为 i，判断`Need[i][j]`是否小于等于`Work[j], 0 <= j <= m`，若全满足，为其分配资源，更新`Work[j], Allocation[i][j], Need[i][j]`，执行后释放资源，恢复`Work[j], Available[j]`，设置`Finish[i] = true`
- 重复第二步，寻找下一个符合的进程，直到遍历结束，若存在进程 k 使得`Finish[k] = false`，说明处于不安全状态，否则处于安全状态

注意这里安全性的判断遵循进程编号的先后顺序，从前往后遍历，每次寻找都从头开始，即完成一个进程后，将其从队列中删除，从头开始遍历寻找下一个进程

栗子

<img src="/home/northboat/Desktop/reco/Docs/docs/.vuepress/public/img/截图_2022-10-26_14-03-31.png">

<img src="/home/northboat/Desktop/reco/Docs/docs/.vuepress/public/img/截图_2022-10-26_14-03-51.png">

<img src="/home/northboat/Desktop/reco/Docs/docs/.vuepress/public/img/截图_2022-10-26_14-04-16.png">

<img src="/home/northboat/Desktop/reco/Docs/docs/.vuepress/public/img/截图_2022-10-26_14-04-51.png">

<img src="/home/northboat/Desktop/reco/Docs/docs/.vuepress/public/img/截图_2022-10-26_14-05-13.png">

在例题中，我们称 P0、P2、P4 打头不存在安全序列，安全序列只有可能由 P1、P3 打头，且 P1 存在安全序列

## 死锁检测和解除

既不预防，也不避免，让系统自己去运行，运行系统发生死锁。此时，系统在固定的时间周期运行死锁检测算法和死锁解除算法，判断系统是否发生死锁。若发生死锁，用死锁解除算法将系统从死锁状态解脱出来

必须对死锁的发生足够敏感，并精确确定与死锁有关的进程和资源（进程 - 资源循环链），系统必须保存资源的请求和分配信息

### 资源分配图及其简化

资源分配图：描述系统资源的分配和空闲情况，用于检测死锁

- G = ( N, E )，N 为 G 的顶点集合，E 表示 G 的边集合
- 顶点包括所有进程和资源
- 边有向
  - 若从资源指向进程，则为进程占用资源，称为**占用边**
  - 若从进程指向资源，则为进程请求资源，称为**请求边**

如

<img src="/home/northboat/Desktop/reco/Docs/docs/.vuepress/public/img/截图_2022-10-26_14-44-39.png">

顶点集`N = {P1, P2, R1, R2}`

边集`E = {<P1, R2>, <R2, P2>, <R1, P1>, <R1, P1>, <R1, P2>, <P2, R1>}`

简化资源分配图：利用简化资源分配图可以判断当前系统是否存在死锁

- 找到一个不阻塞且不独立的进程节点 P
- 不阻塞意味着资源能够满足其运行，于是我们释放 P 所有的资源，删除和 P 相关的所有边（请求边和占用边），使其孤立
- 继续考虑其他非孤立节点
- 直到所有顶点均孤立，说明不存在死锁，若不能使所有进程孤立，则发生了死锁，称这个图不可完全简化

### 死锁检测中的数据结构

