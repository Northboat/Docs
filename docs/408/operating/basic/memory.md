---
title: 存储管理
date: 2022-10-27
tags:
  - OperatingSystem
---

## 内存管理的基本概念

> 内存管理，又称实存管理

### 逻辑地址空间和物理地址空间

程序和数据执行前需存储于内存。为管理方便，用户编写的程序和最终执行的代码位于不同的地址空间（逻辑地址和物理地址）

程序从编写到执行

- 编辑
- 编译：二进制模块
- 链接：二进制模块连接库函数等，变为装入模块
- 装入：将装入模块装入内存
- 执行

计算机常使用的 3 类地址

- 符号地址：存储变量名、函数名等，符号地址空间或名空间
- 逻辑地址：目标代码所使用地址从 0 开始编号，相对地址
- 物理地址：绝对地址，实地址

### 地址变换和内存共享及保护

重定位：将逻辑地址转化为物理地址

- 静态重定位：装入时一次性完成地址转换
- 动态重定位：边执行边进行地址变换，程序在内存中可移动

内存共享：多个进程通过一个物理内存区域进行通信的方式，常见共享方式如下

- 生产者 - 消费者
- 可重入代码：纯代码，执行期间不改变（只读，由 OS 实现），可共享，如编辑软件、编译软件、运行时库、窗口系统、数据库系统等

内存保护

- 存取控制保护：读、写、执行操作权限控制，如`chmod 777 nmsl.txt`
- 地址越界保护：确保每个程序只能访问其所属内存地址空间，保护其他程序正常执行
  - 上下界寄存器：分别表示用户程序内存地址空间的最小 / 大地址，在执行时与之比较，超出范围`[x,y]`则报错
  - 基质 / 重定位寄存器和界限寄存器：记录内存最小值和程序长度，访问时通过`[x,x+len]`进行判断

### 内存的分配和回收

内存分配和回收：内存分为系统区和用户区，系统区放 OS，用户区放用户程序

- 分配和回收，以及多道程序，其操作对象一般都是用户程序，均工作在内存用户区

碎片：存储分配中无法利用（容量太小，没有利用价值）的内存空间

- 内部碎片：分配给用户程序的用户空间中没有被占用、也不允许其他程序占用的空间。固定大小的存储分配可能导致内部碎片，如固定分区、页式管理、段页式管理等
- 外部碎片：用户区剩余的、无法利用的存储空间。非固定大小的存储分配可能导致外部碎片，如动态分区、分段存储分配等

### 连续分配管理方式

为用户程序分配连续的内存空间，使得用户程序的逻辑地址相邻，则物理地址也相邻

特点

- 整体性，用户程序全部装入内存（覆盖技术可允许部分装入）
- 不支持虚拟存储器
- 作业运行结束才释放所占空间

连续存储管理方式：单一连续分区；固定分区；可变分区

单一连续分区：内存用户区最多存放一个用户程序，属于计算机早期的存储方式

- 静态分配，管理简单
- 存在内部碎片；存储器利用率低（单道）；无法实现多道程序共享内存；仅适用于单用户单任务操作系统

固定分区：用户区事先划分为多个分区，每个分区最多可存放一个用户程序，是最早、最简单的可运行多道程序的分区式存储管理模式

- 各分区大小可以相等，也可以不等
  - 当大小相等：适用于一台计算机控制多个相同对象的场合
  - 当大小不等：灵活性更高，通常划分为多个较小分区、适量中等分区、少量的大分区；一般来说小分区位于物理地址的小地址端，大分区反之
- 使用数据结构**分区使用表**管理各个固定分区，记录各个分区的分区号、容量、编号、起始地址和状态信息等，都是事先规定且不能更改的
- 在使用时，OS 首先查询分区使用表，查不到能用的则拒绝执行进程
  - 比较所需内存和分区内存大小
  - 查询分区状态，是否已装入
- 特点：事先划分分区，每个分区装一个作业；多个分区并发执行；采用静态重定位技术装入内存
  - 可用于多道程序系统，可采用覆盖技术，利用率较高
  - 存在区内部碎片，且需要考虑各任务干扰问题，需要内存保护

可变分区：将用户区分为若干分区，分区的大小、个数可灵活变化

- 空闲分区表：每个空闲分区（空闲或未分配）占一个条目，在空闲分区表中，相邻空闲取需要合并

- 空闲分区链：一个双向链表，将所有空闲分区连接起来，其节点信息类似于

  ```c
  struct node{
      node* pre; // 前驱
      node* next; // 下一条
      int mem_size; // 分区大小
      int status; // 0 为空闲，1 为已分配
  }
  ```

首次适应算法

- 空闲分区表按首地址递增排列，顺序查找，直到找到大小满足的空闲分区
- 找到后，根据作业所需大小分配该空闲分区，多余的部分仍存在空闲分区表中（修改相应表项）
- 未找到，分配失败

循环首次适应算法：从上次找到的空闲分区的下一个分区开始，寻找符合的内存区域，找到后分配出和作业所需大小一样的内存

- 减少查找开销，避免低地址区存在很多很小的空闲分区
- 造成大分区分得比较小，不利于大作业装入

最佳适应算法：空闲分区按容量大小递增排序，每次找到最小的符合作业大小的分区并分配内存

- 贪婪思想的表现，每步均为最佳
- 可能产生许多难以利用的小空闲区，宏观上不一定最佳

最差适应算法：空闲分区按容量大小递减排序，每次分配时将最大的满足作业的分区进行分隔，降低剩余空间

- 分配后的空闲区较大，便于下次使用
- 后期不利于大作业装入

快速适应算法：又称分类搜索算法，将内存空间大小相同的空闲分区分为一类，并将同类分区通过双向链表相连，同时建立一张分类表索引，记录各类分区的表头指针；当查找分区时，找到最适合的类（最小的大于）的第一快空闲分区进行分配

- 回收空间的算法复杂；一个分区一个进程，同样会造成区内空间浪费（连续性分配管理的通病）

伙伴系统

非连续存储管理：页式管理；段式管理；段页式管理

## 虚拟内存管理

> 基于实存管理，出应用题

基本概念

请求页式管理

页框分配

页置换算法

内存映射文件

性能改进方法
