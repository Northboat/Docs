---
title: 编译原理概述和词分器
date: 2021-10-1
tags:
  - Compilation
---

> 国防科大网课

## 引论

### 编译程序

#### 翻译程序

翻译程序（Translator）：将某一种语言程序（源语言程序）等价地转换成另一种语言程序（目标语言程序）的程序

#### 编译程序

编译程序（Compiler）：将一种高级语言等价地转换成另一种低级语言程序（如汇编或机器语言程序）的程序

诊断编译程序（Diagnostic Compiler）：发现程序中的错误，帮助程序员调试排错，转换目标代码效率较低

优化编译程序（Optimizing Complier）：目的在于提高转换效率

交叉编译程序（Cross Compiler）：若一个编译程序产生不同于其宿主机（编译程序所在机器）的机器代码，则称其为交叉编译程序

可变目标编译程序（Retargetable Complier）：不需要改变底层逻辑，只需要修改和目标机器有关的部分，便可转化成目标机器代码代码

#### 解释程序

不产生目标程序，边解释边执行源程序，直到把所有的源语言程序解释执行完成

#### 编译与解释

笔译与口译

### 为什么学习编译原理

1. 理解计算系统
2. 设计计算系统
3. 训练**计算思维**（Computational Thinking）
   - 抽象
   - 自动化
   - 问题分解
   - 递归
   - 权衡
   - 保护、冗余、容错、纠错和回复
   - ......

#### 1、计算思维

- 编译理论和技术
  - 计算机科学与技术理论与实践结合的最好体现
- 思维方法
  - 抽象：忽略无关问题，抽象其本质特征（如图灵机：一条无限长纸带、一个读写头、一个状态寄存器、一套控制读写头的规则 ——> 可计算 == 图灵可计算）（又如有限自动机）
  - 自动化：将抽象思维的结果在计算机上实现，将计算思维成果物化的过程，不仅体现在编程，更体现在编译器的研究和设计上
  - 分解：Fork/Join，将大规模问题分解成校问题加以解决
  - 递归（Recursion）：问题的解决依赖于类似问题的解决，只不过后者的复杂程度或规模较原来问题更小，一旦简化到足够小时，算法将变得很简单。编译原理中的递归：递归下降分析、基于树遍历的属性计算、语法制导编译......
  - 权衡（折衷）：在理论可实现和实际可实现之中权衡。如用上下文无关文法去描述和处理高级程序设计语言以及优化措施的选择等等

#### 2、编译原理和方法应用

- HTML / XML 分析
- 语言处理工具
- 搜索引擎

那些计算机技术中应用了语言的翻译或变换？

- 用户接口：Shell命令解释器
- 查询语言：SQL、XQuery
- 网络协议：HTTP

### 编译过程

<img src="./../../../.vuepress/public/img/image-20210921225428808.png">

#### 词法分析

任务：输入源程序，对源程序字符串进行扫描和分解，识别出单词符号

依循原则：构词规则

描述工具：有限自动机

#### 语法分析

任务：在此法分析的基础上，根据语法规则把单词符号串分解成各类语法单位（语法范畴）

依循原则：语法规则

描述工具：上下文无关文法 

【用一棵树表示一个赋值语句】

<img src="./../../../.vuepress/public/img/image-20210923093357647.png">

#### 中间代码产生

任务：对各类语法单位按语言的语义进行初步翻译

依循原则：语义规则

- 如 A = x + y，先计算 x+y，再把值送到赋值号左侧

描述工具：属性文法

中间代码：三元式、四元式、树

- Z = X + 0.618 * Y 翻译成四元式的中间代码

  | 序号 | OPR  | OPN1  | OPN2 | RESULT | 注释       |
  | ---- | ---- | ----- | ---- | ------ | ---------- |
  | 1    | *    | 0.618 | Y    | T1     | T1=0.618*Y |
  | 2    | +    | X     | T1   | T2     | T2=X+T1    |
  | 3    | =    | T2    |      | Z      | Z=T2       |

#### 优化

任务：对前阶段产生的中间代码进行加工变换，以期再最后阶段产生更高效（时间、空间）的目标代码

依循原则：程序的等价变换规则

源代码：

~~~java
for(int k = 1; k <= 100; k++){
    x = i+1;
    m = i+10*k;
    n = j+10*k;
}
~~~

中间代码：

| 序号 | OPR  | OPN1 | OPN2 | RESULT | 注释                   |
| ---- | ---- | ---- | ---- | ------ | ---------------------- |
| 1    | =    | 1    |      | k      | k=1                    |
| 2    | j <  | 100  | k    | (10)   | if(k > 100)  goto (10) |
| 3    | +    | i    | 1    | x      | x = i+1                |
| 4    | *    | 10   | k    | T1     | T1 = 10*k              |
| 5    | +    | i    | T1   | m      | m = i+T1               |
| 6    | *    | 10   | k    | T2     | T2 = 10*k              |
| 7    | +    | j    | T2   | n      | n = j+T2               |
| 8    | +    | k    | 1    | k      | k = k+1                |
| 9    | J    |      |      | (2)    | goto(2)                |
| 10   |      |      |      |        |                        |

共400次加法，200次乘法

优化中间代码：

| 序号 | OPR  | OPN1 | OPN2 | RESULT | 注释                  |
| ---- | ---- | ---- | ---- | ------ | --------------------- |
| 1    | +    | i    | 1    | x      | x = i+1               |
| 2    | =    | i    |      | m      | m = i                 |
| 3    | =    | i    |      | n      | n = i                 |
| 4    | =    | 1    |      | k      | k = 1                 |
| 5    | j <  | 100  | k    | (10)   | if(k > 100)  goto(10) |
| 6    | +    | m    | 10   | m      | m = m+10              |
| 7    | +    | n    | 10   | n      | n = n+10              |
| 8    | +    | k    | 1    | k      | k = k+1               |
| 9    | J    |      |      | (5)    | goto(5)               |
| 10   |      |      |      |        |                       |

共300次加法

#### 目标代码产生

任务：把中间代码变换成特定机器上的目标代码

依赖于硬件系统结构和机器指令的含义

目标代码三种形式

1. 汇编指令代码：需要进行汇编

2. 绝对指令代码（机器语言程序）：可直接运行

3. 可重新定位指令代码：需要连接

   如 .obj 文件 ——> .exe 文件

十六位原二进制码：

- 前四位：操作数
- 接下来两位：寄存器操作数
- 再接下来两位：第二个操作数类型（地址还是立即数）
- 后八位：表示地址或立即数

经过可重定位指令代码：后八位数变化 ——> 绝对指令代码

### 编译程序的结构

#### 编译程序总框

词法分析器：源程序 ——> 单词符号

语法分析器：单词符号 ——> 语法单位

语义分析与中间代码生成器：语法单位 ——> 中间代码（四元式）

优化段：中间代码 ——> 中间代码（效率更高）

目标代码生成器：中间代码 ——> 目标代码

- 符号表管理与上述每个阶段打交道
- 出错处理（全面准确、甚至纠错建议）

#### 出错处理

出错处理程序

- 发现源程序中的错误，把有关错误信息报告给用户

语法错误

- 源程序中不符合语法（或词法）规则的错误
- 非法字符、括号不匹配、缺少......

语义错误

- 与程序中不符合语义规则的错误
- 说明错误、作用域错误、类型不一样



#### 遍（pass）

对源程序或源程序的中间表示从头到尾扫描一次，每次遍都是源程序的一次完整表示

一般出于效率考虑，将词法分析、语法分析（起主导作用）、中间代码处理合成一遍完成

- 阶段和遍是不同的概念：一遍可用由若干段组成，一个阶段也可以分若干遍来完成

一般来说，优化这个阶段由很多遍组成

#### 编译前端与后端

源语言 —[编译前端]—> 中间语言 —[编译后端]—> 目标语言

编译前端

- 与源语言有关：如词法分析，语法分析，语义分析，中间代码产生以及与机器无关的优化

编译后端

- 与目标机器有关：与目标机器有关的优化，目标代码的产生

好处

- 程序逻辑结构清晰
- 优化更充分，移植性更高（前后端分离）

### 编译程序的生成

以机器语言和汇编语言为工具

- 优点：可以针对具体的机器，充分发挥计算机的系统功能，生成的程序效率高
- 缺点：程序难读难写、易出错、难维护、生产效率低

高级语言书写

- 利用已有的某种语言的编译程序实现另一语言的编译程序
- 优点：程序易读、易理解、容易维护、生产效率高

编译程序的移植

- 把一种极其上的编译程序移植到另一种机器上
- 究极套娃：
  1. 首先我们拥有一个A代码编译器P1，它可以将L语言翻译成A代码。
  2. 现在，我们手写一个L语言的编译器P2，仅仅是源代码，它可以将L语言翻译成B代码。
  3. 接着，我们用A代码编译器编译这个用L语言写的编译器的源代码，得到A代码版本的P2’（可执行程序），P2‘实现了P2的功能，能将L语言翻译成B代码，从L代码实现变成了用A代码实现
  4. 最后，我们用P2’编译P2（将L语言翻译为B代码），终于把用L语言写的编译器P2源码编译为B代码实现的编译器P2‘’，同样实现了P2的功能，将L语言转换为B代码

<img src="./../../../.vuepress/public/img/image-20210923165335119.png">

自编译方式

- 当我们需要L语言的编译器
  1. 用L语言的核心L1语言（可以是低级语言）构造一个小编译器
  2. 以L1为开发工具，构造能够编译翻译更多语言成分的编译工具：L1+L2......
  3. 通过一系列自展途径完成对L语言编译器的开发

编译程序自动产生（自动产生工具）

- 编译程序-编译程序，编译程序产生器，编译程序书写系统
- LEX：词法分析程序产生器
- YACC：语法分析程序产生器

### 小结

课程概述：内容、意义

什么是编译程序：翻译（语言 —> 程序）、编译（高级语言 —> 低级语言）、解释

编译基本过程：词法分析、语法分析、中间代码生成、优化、目标代码生成

编译程序的结构：阶段、遍、前端/后端

编译程序生成的几种方法

## 高级程序设计语言概述

### 常用的高级程序设计语言

| 语言      | 特点                   |
| --------- | ---------------------- |
| FORTRAN   | 数值计算               |
| COBOL     | 事务处理               |
| PASCAL    | 结构化程序设计         |
| LISP      | 函数式程序设计         |
| PROLOG    | 逻辑程序设计           |
| C         | 系统程序设计           |
| SmallTalk | 面向对象程序设计       |
| Java      | Internet应用、可移植性 |
| Python    | 解释型、动态编程       |

优点

- 更接近于数学语言和工程语言、更直观、自然和易于理解
- 更容易验证其正确性、改错
- 编写程序的效率更高
- 更容易移植

### 程序设计语言的定义

#### 语法

- 程序本质上是一定字符集上的字符串，只有符合程序语言语法的字符串才是正确的程序
- 语法：一组规则，用它可以形成和产生一个合式（well-formed）的程序

词法规则：单词符号形成的规则

- 单词符号是语言中具有独立意义的最基本结构
- 一般包括：常数、标识符、基本字、算符、界符等
- 描述工具：有限自动机

语法规则：语法单位的形成规则

- 语法单位通常包括：表达式、语句、分程序、过程、函数、程序等
- 描述工具：上下文无关文法

如语法：

E ——> i：一个算数表达式可由一个标识符或常数构成

E ——> E + E：一个算数表达式可由小表达式组合而成

E ——> E * E：一个算数表达式可由两个表达式通过 * 号连接而成

E ——> （E）：当算数表达式加上括号，仍为一个算数表达式

- 语法规则和词法规则定义了程序的形式结构
- 定义语法单位的**意义**属于语义问题

#### 语义

- 一组规则，用它可以定义一个程序的意义

描述方法

- 自然语言描述
  - 二义性、隐藏错误和不完整性
- 形式描述
  - 操作语义
  - 指称语义
  - 代数语义



语用（暂不考虑）

#### 基本功能和层次结构

程序

- 本质上说是描述一定数据的处理过程

程序语言的基本功能

- 描述数据和对数据的运算

程序的层次结构

- 程序的层次结构能够让人们从下至上理解

<img src="./../../../.vuepress/public/img/image-20210923175452093.png">

程序语言成分的逻辑和实现意义

- 抽象的逻辑意义
  - 数学意义
- 计算机实现的意义
  - 具体实现

### 高级程序设计语言一般特性

#### 高级语言的分类

强制式语言（Imperative Languge）

应用式语言（Applicative Language）：LISP、ML

基于规则的语言（Rule-based Language）：ProLog

面向对象的语言（Object-Oriented Language）

#### 程序结构

##### FORTRAN

第一个高级设计语言

- 一个程序由一个主程序段和若干辅程序段组成
- 辅程序段可以是子程序、函数段或数据块
- 每个程序段由一系列的说明语句和执行语句组成，各段可以独立编译
- 模块结构，没有嵌套和递归
- 各程序段中的名字相互独立，同一个标识符在不同的程序段中代表不同的名字

##### PASCAL

- `PSCAL`程序本身可以看成是一个操作系统调用的过程，过程可以嵌套和递归
- 一个PASCAL过程：
  - 过程头
  - 说明段：由一系列的说明语句组成
  - 执行体：由一系列的执行语句组成
- 作用域
  - 同一个标识符在不同过程中代表不同的名字
  - 作用域：一个名字能被使用的区域范围
  - 名字作用域规则：最近嵌套原则
- 最近嵌套原则
  - 一个在子程序B1中说明的名字X只在B1中有效（局部作用域B1），生命周期与B1相同
  - 如果B2是B1的一个内层子程序且B2中对标识符没有新的说明，则原来的名字X对B2仍然有效
  - 弱国B2对X重新作了说明，那么B2对X的任何引用都是指重新说明过的这个X

##### JAVA

- 面向对象的高级语言

#### 数据结构与操作

数据类型三要素

- 用于区别这种类型数据对象的属性
- 这种类型的数据对象可以具有的值
- 可以作用域这种数据类型的操作

初等数据类型

- 数值类型
  - 整型、实型、复数、双精度
  - 运算：+、-、*、/ 等
- 逻辑类型
  - true、false
  - 布尔运算
- 字符类型：符号处理
- 指针类型

标识符与名字：标识符是语法概念，名字是语义概念

- 标识符
  - 以字母开头，由字母数字组成的字符串（没有意义）
- 名字
  - 标识程序中的对象

标识符在绑定某一事物后变成名字，如Jardon与乔丹绑定，Jardon与约旦绑定

- 名字的意义和属性

  - 值：单元中的内容
  - 属性：类型和作用域

- 名字的说明方式

  - 由说明语句来明确规定的：int score

  - 隐含说明：FORTRAN中以I、J、K、N为首的名字代表整型，否则为实型
  - 动态确定：走到哪里，是什么，算什么

名字的绑定

- 静态绑定：常量、变量
- 动态绑定：c++虚函数

> 数据结构

数组

- 可变与不可变：编译时能否确定其存储空间的大小
- 存放方式：按行存放、按列存放
- 内情向量：存放每一维向量的上下限以及个数

记录（结构体）

- 由已知类型的数据组合在一起的一种结构
- 记录或者结构的元素，也叫做域
- 存储：连续存放

字符串、表格、栈

- 字符串：符号处理、公式处理
- 表格：本质上是一种记录结构
- 线性表：一组顺序化的记录结构
- 栈：一种线性表，后进先出，pop、push

抽象数据类型

- 一个抽象数据类型包括
  - 数据对象集合
  - 作用于这些数据对象的抽象运算的集合
  - 这种类型对象的封装，即，除了使用类型中所定义的运算外，用户不能对这些对象进行操作
- 程序设计语言对抽象数据类型的支持
  - Ada通过程序包（package）提供了数据封装的支持
  - C++抽象类
  - JAVA接口、抽象类

#### 语句与控制结构

表达式

- 表达式由运算量（操作数）和算符（运算符）组成
- 形式：中缀、前缀、后缀
- 表达式形成规则
  - 变量、常数是表达式
  - 若E1、E2是表达式，^是一个二元算符，则E1^E2是一个表达式
  - 若E是表达式，^为一元算符，则^E是表达式
  - 若E是表达式，则（E）是表达式
- 算符的优先次序
  - 一般的规定
    - PASCAL：左结合，如A+B+C=(A+B)+C
    - FORTRAN：对于满足左、右结合的算符可任取一种结合方式
  - 代数性质
    - 代数性质能引用到什么程度视具体的语言而定
    - 在数学上成立的代数性质在计算机上不一定成立，如 A+B!=B+A 在程序中很可能成立（字符串的拼接）

语句

- 赋值语句
  - A = B
  - 名字的左值：该名字代表存储单元的地址
  - 名字的右值：改名字代表存储单元的内容
- 控制语句
  - 无条件转移语句：goto
  - 条件语句：if/else
  - 循环语句：while/for
  - 过程调用语句
  - 返回语句：return
- 语句的分类
  - 功能
    - 执行语句：描述程序的动作
    - 说明语句：定义各种不同数据类型的变量或运算，定义名字的性质
  - 形式
    - 简单句：不包含其他语句成分的基本句
    - 复合句：句中有句的语句

### 小结

程序语言的定义

- 语法
- 语义
- 程序语言的功能

高级语言的一般特性

- 高级语言的分类
- 程序结构
- 数据结构于操作
- 语句于控制结构

## 程序设计语言的语法描述

### 文法

> 描述语言的语法结构的形式规则

**语法描述的几个基本概念**

- 字母表：一个有穷字符集，记为Σ
- 字母表上每个元素称为字符
- Σ上的字（字符串）是指由Σ中的字符所构成的一个有穷序列
- 不包含任何字符的序列称为空字
- 用Σ※表示Σ上所有字的全体，如Σ={a，b}，则Σ※={空，a，b，aa，bb，aab，aba......}
- 字集的积：字集的连接（有顺序）
- 字集的闭包
- 字集的正规闭包：比闭包少一个空集

**上下文无关文法**

- 上下文无关文法G是一个四元组：G=（V1,V2,S,P），其中

  - V1：终结符（Terminal）集合（非空）
  - V2：非终结符（Nonterminal）集合（非空），且V1、V2不相交
  - S：文法的开始符号，S∈V2
  - P：产生式集合（有限），每个产生式形式为
    - P ——> α，P∈V2，α∈(V1∪V2)
  - 开始符S必须在产生式的左侧出现一次

- 巴克斯范式（BNF）

- 约定

  - P —>a1 | a2 | a3 | ... . an，其中“|”读作或，称ai为P的一个候选式

- 推导

  - 最左推导：任何一步 α => β 都是对阿尔法中的最左非终结符进行替换

    ~~~
    E -> E + T
    -> T + T
    -> F + T
    -> i + T
    -> i + T * F
    -> i + F * F
    -> i + i * F
    -> i + i * i
    ~~~

  - 最右推导：任何一步 α => β 都是对阿尔法中最有非终结符进行替换

    ~~~
    E -> E + T
    -> E + T * F
    -> E + T * i
    -> E + F * i
    -> E + i * i
    -> T + i * i
    -> F + i * i
    -> i + i * i
    ~~~

  - 直接推出：当aAb =>aβb，则称aAb直接推出aβb

  - 可推导：若存在a1=>a2=>a3...=>an的一个推到，则称a1可以推导出an

    ~~~
    如对文法G(E)：由E —> i | E+E | E*E | (E)
    
    有 E=> (E) => (E+E) => (I+E) => (I+I)
    ~~~

  - 星号推出*：经过0步或若干步推出结果

  - 加号推出+：经过1步或若干步推出结果

- 句型、句子和语言

  - 句型：若G是一个文法，S是他的开始符，如果S星号推出a，则称a是一个句型
  - 仅含终结符号的句型是一个句子
  - 文法G所产生的句子的全体是一个语言，记为L（G）
  - 文法 —— 递归 ——> 语言

- 语法树与二义性

  - 文法的二义性：如果一个文法存在某个句子对应两颗不同的语法树（左推导和右推导导致树不一样），则说这个文法是二义的
  - 语言的二义性：如果某个语言存在二义的文法，则这个语言是二义的。如：John saw Mary in a boat => john在船上看到mary，john看见mary在船上
  - 如何判断一个文法是否二义：不可判定问题

### 形式语言鸟瞰

乔姆斯基建立的形式语言体系将文法分成四种类型：0、1、2（上下文无关文法）、3型

四种文法都由四个部分构成，且前三个部分相同

- 0型（短语文法，图灵机）
- 1型（上下文有关文法，线性界限自动机）
- 2型（上下文无关文法，非确定下推自动机）：栈式的工作方式
- 3型（正规文法，有限自动机）

描述能力：0>1>2>3

现今的程序设计语言均由上下文无关文法编写：成熟高效

超出上下文无关文法的约束的部分通过语义分析来检查，而不是通过语法分析纠错

理论可实现和实际可实现的权衡

### 小结

1、文法、推导

- 文法 <=> 语言
- 最左推导、最右推导

2、语法树

3、二义性

- 文法的二义性、语言的二义性

4、乔姆斯基形式语言体系

## 词法分析器

### 词法分析器的设计

#### 概述

任务：扫描源程序，产生单词符号

词法分析器（Lexical Analyzer）

- 扫描器（Scanner）
- 执行词法分析的程序

功能：源程序 ——> 单词符号

单词符号

- 基本字：begin，repeat，for
- 标识符：变量名、数组名、过程名
- 常数
- 运算符
- 分界符

单词的组成：单词种别、单词自身的值

单词种别：常用整数编码表示

词法分析作为一个独立的阶段

- 令编译器结构清晰简洁，有利于集中考虑词法分析一些细节问题
- 不一定不作为一个遍

源程序与词法分析器交互，词分器与语分器交互，符号表在这一过程不断与词分器和语分器交互

#### 词分器的结构

输入缓冲区

预处理子程序

扫描缓冲区：防止缓冲区打断一个完整单词 ——> 两个半区互补使用（循环往复）——> 半区的长度便是程序语言允许的最大单词长度

- 起点指示器：指向单词头
- 搜索指示器：搜索单词尾

扫描器

#### 超前搜索

避免防止分析一个句子时不断DFS向前回溯识别 ——> 即避免超前搜索

- 标识符识别
- 常数识别
- 算符和界符的识别

几点限制

- 不能用基本字作为标识符
- 基本字作为特殊标识符处理，使用保留字表
- 需要用空白符分隔开没有用确定算符或界符作间隔的基本字、标识符和常数

#### 状态转换图

有限方向图

- 结点表示状态
- 箭头连结，箭头上标记代表可能出现的字符
- 有限个状态，一个初态，至少一个终态

状态转换图的识别

- 初态到某一终态拼接而成的字符串为可被识别的字符串

#### 状态转换图的实现

不含回路的分叉节点

- 可用if、else if、else语句实现

含回路的状态节点

- 自圈回路：循环执行
- 对应一段由while、if语句构成的程序

终态结点

- return语句：key，value

我们定义十个全局变量和过程

- ch字符变量，存放最近的源程序字符
- strToken数组，存放构成单词的字符串
- GetChar过程，将字符读到ch中
- GetBC过程，跳过空白符
- Concat程序，把ch连接到strToken
- IsLetter/IsDigit布尔函数，判断字符类型
- Reserve整型函数，查询保留字表
- Retract子程序，把搜索指针回调一个字符
- InsertId整形函数，将strToken的标识符插入符号表，返回一个指针，指向符号表中的当前id对应的值
- InsertConst整型函数，将strToken中的常数插入常数表，返回常数表指针

#### 词分器的实现



### 正则表达式与有限自动机



### 词法分析器的自动产生-LEX
